<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SwitchUp Poker</title>
    <style>
        /* --- General Styling and Layout --- */
        body {
            font-family: Arial, sans-serif;
            background-color: #E0FFFF; /* Light Cyan Background (Uniform) */
            color: #000; /* Default text color set to black for light background */
            text-align: center;
            padding: 0;
            margin: 0;
            min-height: 100vh; 
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        #main-container {
            display: flex;
            justify-content: center;
            gap: 25px;
            max-width: 1400px; 
            margin: 0 auto;
            width: 95%;
            padding: 20px 0;
        }

        /* --- Game Containers (Unified Background) --- */
        #game-container, #payout-container {
            background-color: #F0FFFF; /* Very Light Cyan / Azure */
            border-radius: 15px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
            padding: 30px;
        }
        
        #game-container {
            flex-grow: 1;
            max-width: 900px;
            position: relative;
        }
        
        /* --- Company Logo Styling FIX --- */
        #company-logo {
            position: absolute;
            bottom: 15px; 
            left: 20px; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            font-size: 1.5em; 
            font-weight: bold;
            letter-spacing: 1.5px;
            
            /* Enable Gradient on Text */
            background: linear-gradient(45deg, #FFD700, #FF69B4, #00BFFF); 
            -webkit-background-clip: text; 
            -webkit-text-fill-color: transparent; /* Ensures text is transparent */
            background-clip: text;
            color: transparent; /* Fallback for transparency */
            
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.4); /* Darker shadow for visibility */
            display: inline-block; /* Essential for gradient rendering */
        }


        /* --- Payout Table Styling --- */
        #payout-container {
            width: 300px;
            max-height: 420px; 
            color: #333;
        }

        #payout-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 1em;
            margin-top: 10px;
        }

        #payout-table th {
            padding: 10px 10px;
            background-color: #A9D1E4; 
            color: #000;
            border-bottom: 2px solid #000;
            text-align: center;
        }

        #payout-table td {
             padding: 8px 10px;
             border-bottom: 1px solid #A9D1E4; 
             text-align: left;
        }
        
        #payout-table tr:nth-child(even) {
            background-color: #F8FFFF;
        }

        /* NEW: Highlight win row */
        #payout-table tr.highlight-win {
            background-color: #FFA500 !important; 
            color: #000;
            font-weight: bold;
            transform: scale(1.03);
            transition: background-color 0.5s;
        }
        
        #payout-table td:last-child {
            text-align: right; 
            font-weight: bold;
            color: #000;
        }
        
        /* --- Stats and Message Area --- */
        #stats-bar {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
            padding: 10px;
            background-color: #E0FFFF; 
            border-radius: 8px;
            color: #000; 
        }

        .stat-box {
            font-size: 1.2em;
            font-weight: bold;
        }
        
        #message-area {
            font-size: 1.5em;
            margin-bottom: 20px;
            min-height: 40px;
            color: #CC0000;
            font-weight: bold;
        }

        /* --- Card Display Area (Playing Cards) --- */
        #card-area {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
            min-height: 180px; 
        }

        .card-slot {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .card-image {
            width: 100px; 
            height: 142px; 
            background-color: #fff;
            border: 3px solid transparent;
            border-radius: 6px;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.4);
            cursor: pointer;
            transition: transform 0.2s, border-color 0.2s;
            
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.8em; 
            color: #000;
            flex-direction: column;
            padding: 5px;
            white-space: pre-wrap;
            text-align: center;
        }
        
        .card-image.red-suit {
            color: #cc0000;
        }

        /* Blue Border ONLY. NO VERTICAL LIFT. */
        .card-image.held {
            border-color: #007bff; 
        }
        
        .card-image.has-image {
            font-size: 0;
        }

        /* --- Buttons (HOLD) - STYLED --- */
        .hold-button {
            padding: 6px 15px;
            margin-top: 10px;
            font-size: 1em; 
            cursor: pointer;
            border: 1px solid #004080; 
            border-radius: 15px; 
            font-weight: bold;
            background-color: #007bff; 
            color: white;
            width: 100%;
            box-shadow: 0 3px 0 #004080; 
            transition: all 0.1s ease-out;
        }
        
        .hold-button:active {
            transform: translateY(2px); 
            box-shadow: 0 1px 0 #004080;
        }

        .hold-button.held {
            background-color: #0056b3; 
            box-shadow: 0 3px 0 #002753;
            border-color: #002753;
        }
        
        .hold-button.held:active {
            transform: translateY(2px);
            box-shadow: 0 1px 0 #002753;
        }

        /* --- Control Buttons --- */
        #control-buttons {
            margin-top: 30px;
            display: flex;
            justify-content: center;
            gap: 30px;
        }

        #control-buttons button {
            padding: 15px 30px;
            font-size: 1.3em;
            cursor: pointer;
            border: none;
            border-radius: 10px;
            background-color: #ffc107;
            color: #333;
            font-weight: bold;
        }
        
        #control-buttons button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }
        
        /* --- Joker Cards Container --- */
        #action-cards-container {
            display: flex;
            justify-content: center;
            gap: 40px; 
            margin-top: 30px; 
            padding: 20px; 
            background-color: #E0FFFF;
            border-radius: 10px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.1);
        }
        
        .action-card-slot {
            opacity: 1;
            transition: opacity 0.3s;
        }

        .action-card-slot.used {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .action-card-button {
            background-color: #6f42c1;
            color: white;
            width: 180px; 
            height: 130px; 
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            line-height: 1.2;
            border: 3px solid transparent;
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.2s, border-color 0.2s, opacity 0.2s;
            
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
            color: transparent;
            font-size: 0;
        }
        
        .action-card-button:hover:not(:disabled) {
            transform: translateY(-5px); 
        }

        .action-card-button.selected {
            border-color: #ffc107;
            transform: scale(1.05);
        }
    </style>
</head>
<body>

    <div id="main-container">
        <div id="game-container">
            <h1>SWITCHUP POKER</h1>
            
            <div id="stats-bar">
                <div class="stat-box">Credits: <span id="credits-stat">500</span></div>
                <div class="stat-box">Total Bet: <span id="bet-stat">10</span></div>
                <div class="stat-box">Last Win: <span id="winnings-stat">0</span></div>
            </div>

            <div id="message-area">Welcome! Click 'DEAL' to start.</div>

            <h2>Your Hand</h2>
            <div id="card-area">
                </div>
            
            <h2>Joker Cards</h2>
            <div id="action-cards-container">
                 </div>

            <div id="control-buttons">
                <button id="deal-button" onclick="game.dealHand()">DEAL</button>
                <button id="draw-button" onclick="game.drawCards()" disabled>DRAW</button>
            </div>
            
            <div id="company-logo">Brightly Games</div>
        </div>

        <div id="payout-container">
            <h2>Payouts (5x)</h2>
            <table id="payout-table">
                <thead>
                    <tr>
                        <th>Hand</th>
                        <th>Pays (Credits)</th>
                    </tr>
                </thead>
                <tbody>
                    <tr data-hand="Royal Flush"><td>Royal Flush</td><td>4000</td></tr>
                    <tr data-hand="Straight Flush"><td>Straight Flush</td><td>250</td></tr>
                    <tr data-hand="Four of a Kind"><td>4 of a Kind</td><td>100</td></tr>
                    <tr data-hand="Full House"><td>Full House</td><td>45</td></tr>
                    <tr data-hand="Flush"><td>Flush</td><td>30</td></tr>
                    <tr data-hand="Straight"><td>Straight</td><td>20</td></tr>
                    <tr data-hand="Three of a Kind"><td>3 of a Kind</td><td>15</td></tr>
                    <tr data-hand="Two Pair"><td>Two Pair</td><td>10</td></tr>
                    <tr data-hand="Jacks or Better"><td>Jacks or Better</td><td>5</td></tr>
                </tbody>
            </table>
        </div>
    </div>

<script>
    // --- 1. Game Constants & Setup ---
    const SUITS = ["clubs", "diamonds", "hearts", "spades"];
    const RANKS = Array.from({length: 13}, (_, i) => i + 2); 
    const STARTING_CREDITS = 500;
    const INITIAL_BET = 5; 
    const MOD_CARD_COST = 5;
    
    // Paytable based on 5x multiplier (using 800 for RF, 20 for 4K)
    const PAYTABLE = {
        "Royal Flush": 4000,
        "Straight Flush": 250,
        "Four of a Kind": 100,
        "Full House": 45,
        "Flush": 30,
        "Straight": 20,
        "Three of a Kind": 15,
        "Two Pair": 10,
        "Jacks or Better": 5,
        "Pair (Below Jacks)": 0, 
        "High Card": 0,
        "Invalid Hand": 0
    };
    
    // UPDATED ACTION CARD DEFINITIONS WITH PROVIDED FILENAMES
    const ACTION_CARD_DEFINITIONS = [
        { name: "upgrade", display: "UPGRADE", filename: "UPGRADE.png" },
        { name: "mirror_hand", display: "MIRROR HAND", filename: "1.png" }, 
        { name: "flush_fever", display: "FLUSH FEVER", filename: "FEVER.png" }, 
    ];
    
    // Helper to find a card by its rank and suit for duplicate checks
    function cardExists(hand, cardToCheck, indexToIgnore) {
        return hand.some((card, index) => 
            index !== indexToIgnore && card && card.isEqual(cardToCheck)
        );
    }
    
    // --- 2. Card Classes ---
    class Card {
        constructor(suit, rank) {
            this.suit = suit;
            this.rank = rank;
            this.rankStr = this.getRankStr();
        }

        getRankStr() {
            const ranksMap = { 11: 'J', 12: 'Q', 13: 'K', 14: 'A' };
            return ranksMap[this.rank] || String(this.rank);
        }
        
        toString() {
            const suitMap = { "clubs": "♣", "diamonds": "♦", "hearts": "♥", "spades": "♠" };
            return `${this.rankStr}\n${suitMap[this.suit]}`;
        }
        
        isEqual(otherCard) {
            return otherCard && this.suit === otherCard.suit && this.rank === otherCard.rank;
        }
    }

    class Deck {
        constructor() {
            this.cards = [];
            this.reset();
        }

        reset() {
            this.cards = [];
            for (const suit of SUITS) {
                for (const rank of RANKS) {
                    this.cards.push(new Card(suit, rank));
                }
            }
            this.shuffle();
        }

        shuffle() {
            for (let i = this.cards.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [this.cards[i], this.cards[j]] = [this.cards[j], this.cards[i]];
            }
        }

        dealCard() {
            if (this.cards.length > 0) {
                return this.cards.pop();
            }
            return null;
        }

        drawCards(hand, heldIndices) {
            for (let i = 0; i < 5; i++) {
                if (!heldIndices.includes(i)) {
                    let newCard = null;
                    let attempts = 0;
                    
                    do {
                        newCard = this.dealCard();
                        attempts++;
                        if (attempts > this.cards.length + 10) break;
                    } while (newCard && cardExists(hand, newCard, i));
                    
                    if (newCard) {
                        hand[i] = newCard;
                    }
                }
            }
            this.shuffle(); 
        }
    }
    
    // --- 3. Evaluation Logic ---
    function evaluateHand(hand) {
        if (!hand || hand.length !== 5) return "Invalid Hand";
        const ranks = hand.map(card => card.rank).sort((a, b) => a - b);
        const suits = hand.map(card => card.suit);
        const rankCounts = ranks.reduce((counts, rank) => {
            counts.set(rank, (counts.get(rank) || 0) + 1);
            return counts;
        }, new Map());

        const isFlush = new Set(suits).size === 1;
        const isSequential = ranks[4] - ranks[0] === 4 && new Set(ranks).size === 5;
        const isAceLow = ranks.toString() === '2,3,4,5,14';
        const isStraight = isSequential || isAceLow;
        
        let pairs = 0;
        let threes = 0;
        let fours = 0;
        
        for (const count of rankCounts.values()) {
            if (count === 4) fours++;
            else if (count === 3) threes++;
            else if (count === 2) pairs++;
        }

        if (isStraight && isFlush) {
            if (ranks.toString() === '10,11,12,13,14') return "Royal Flush";
            return "Straight Flush";
        }
        if (fours === 1) return "Four of a Kind";
        if (threes === 1 && pairs === 1) return "Full House";
        if (isFlush) return "Flush";
        if (isStraight) return "Straight";
        if (threes === 1) return "Three of a Kind";
        if (pairs === 2) return "Two Pair";
        
        if (pairs === 1) {
            for (const [rank, count] of rankCounts.entries()) {
                if (count === 2 && rank >= 11) return "Jacks or Better";
            }
            return "Pair (Below Jacks)";
        }
        return "High Card";
    }

    // --- 4. Game Class (Full Logic) ---
    class PokerGame {
        constructor() {
            this.deck = new Deck();
            this.playerHand = [];
            this.heldCards = [false, false, false, false, false];
            this.actionCardsInHand = [];

            this.credits = STARTING_CREDITS;
            this.bet = INITIAL_BET;
            this.modCardCost = MOD_CARD_COST;
            this.lastWinnings = 0;
            this.winningHandName = null;

            this.gameState = "DEAL"; 
            this.selectedActionCard = null; 
            this.activeEffect = null;
            this.actionCardUsedThisRound = false;

            this.message = `Welcome! Credits: ${this.credits}. Total Cost per hand: ${this.bet + this.modCardCost}. Click 'DEAL' to start.`;
            
            this.initActionCards();
            this.updateUI();
        }
        
        initActionCards() {
            this.actionCardsInHand = ACTION_CARD_DEFINITIONS.map(def => ({
                name: def.name,
                display: def.display,
                filename: def.filename,
                isUsed: false
            }));
        }

        dealHand() {
            const totalCost = this.bet + this.modCardCost;
            if (this.gameState !== "DEAL" && this.gameState !== "END_ROUND") return;

            if (this.credits < totalCost) {
                this.message = `Not enough credits! Required: ${totalCost}.`;
                this.updateUI();
                return;
            }

            this.credits -= totalCost;
            this.deck.reset();
            this.playerHand = [];
            for (let i = 0; i < 5; i++) {
                const card = this.deck.dealCard();
                if (card) this.playerHand.push(card);
            }
            
            this.heldCards = [false, false, false, false, false];
            this.actionCardUsedThisRound = false;
            this.selectedActionCard = null;
            this.activeEffect = null;
            this.winningHandName = null;
            this.gameState = "ACTION_PHASE";
            this.message = `Credits: ${this.credits}. Choose a Joker Card or cards to HOLD.`;

            this.initActionCards(); 
            this.updateUI();
        }

        drawCards() {
            if (this.gameState !== "ACTION_PHASE" || this.activeEffect) {
                this.message = "Finish your Joker Card effect or select another card.";
                this.updateUI();
                return;
            }

            const heldIndices = this.heldCards.map((held, i) => held ? i : -1).filter(i => i !== -1);
            this.deck.drawCards(this.playerHand, heldIndices);

            this.gameState = "EVALUATE";
            this.evaluateFinalHand();
            this.updateUI();
        }
        
        evaluateFinalHand() {
            const handName = evaluateHand(this.playerHand); 
            const winnings = PAYTABLE[handName] || 0;

            this.credits += winnings;
            this.lastWinnings = winnings;
            this.winningHandName = handName;

            this.message = `You have a ${handName}! Winnings: ${winnings}. Credits: ${this.credits}. Click 'DEAL' for a new hand.`;
            this.gameState = "END_ROUND";
        }
        
        // --- Hold Logic / Action Card Click Handler ---
        toggleHold(cardIndex) {
            if (this.gameState === "ACTION_PHASE" && !this.activeEffect) {
                this.heldCards[cardIndex] = !this.heldCards[cardIndex];
                this.message = "Choose cards to hold, then click 'DRAW'.";
                this.updateUI();
            } else if (this.activeEffect && cardIndex !== null) {
                this.applyActionCardEffect(cardIndex);
            }
        }
        
        // --- Action Card Selection Logic ---
        selectActionCard(cardName) {
            const card = this.actionCardsInHand.find(ac => ac.name === cardName);
            if (!card || card.isUsed) return;
            
            if (this.selectedActionCard && this.selectedActionCard.name === cardName) {
                this.selectedActionCard = null;
                this.activeEffect = null;
                this.actionCardUsedThisRound = false;
                this.message = "Joker Card deselected. Choose cards to hold or another Joker Card.";
                this.updateUI();
                return;
            }

            if (this.actionCardUsedThisRound) {
                this.message = "You have already used a Joker Card this round.";
                this.updateUI();
                return;
            }

            this.selectedActionCard = card;
            this.activeEffect = cardName;
            this.actionCardUsedThisRound = true;

            if (cardName === "mirror_hand") {
                 this.applyActionCardEffect(null);
            } else {
                 this.message = `Action: ${card.display} selected. Click a card to apply the effect.`;
                 this.updateUI();
            }
        }
        
        // --- Action Card Application Logic ---
        applyActionCardEffect(clickedCardIndex) {
            const hand = this.playerHand;
            const cardToModify = hand[clickedCardIndex];
            
            // 1. Logic for Mirror Hand (Immediate Effect)
            if (this.activeEffect === "mirror_hand" && clickedCardIndex === null) {
                let cardsUpgradedCount = 0;
                const changesToApply = [];
                const cardsSkippedDueToDuplicate = [];

                for (let i = 0; i < hand.length; i++) {
                    const cardOriginal = hand[i];
                    let newRank = cardOriginal.rank;

                    if (cardOriginal.rank === 2) newRank = 14;
                    else if (cardOriginal.rank === 3) newRank = 13;
                    else if (cardOriginal.rank === 4) newRank = 12;

                    if (cardOriginal.rank !== newRank) {
                        const tempSimulatedCard = new Card(cardOriginal.suit, newRank);
                        
                        if (!cardExists(hand, tempSimulatedCard, i)) {
                            changesToApply.push({ index: i, newRank: newRank });
                        } else {
                            cardsSkippedDueToDuplicate.push({ original: cardOriginal.toString() });
                        }
                    }
                }
                
                changesToApply.forEach(change => {
                    hand[change.index].rank = change.newRank;
                    hand[change.index].rankStr = hand[change.index].getRankStr();
                    cardsUpgradedCount++;
                });

                let details = cardsSkippedDueToDuplicate.length > 0 ? `. Skipped due to duplicates: ${cardsSkippedDueToDuplicate.length}` : "";
                this.message = `Mirror Hand Activated! Upgraded ${cardsUpgradedCount} cards${details}. Choose cards to HOLD.`;
                this.endActionCardEffect();
                return; 
            }

            // 2. Logic for Upgrade and Flush Fever (Require card click)
            if (clickedCardIndex === null || clickedCardIndex === undefined) return;
            
            if (this.activeEffect === "upgrade") {
                const newRank = cardToModify.rank + 1;
                if (newRank > 14) { this.message = "Cannot upgrade an Ace. Choose another card."; this.updateUI(); return; }
                const tempSimulatedCard = new Card(cardToModify.suit, newRank);

                if (cardExists(hand, tempSimulatedCard, clickedCardIndex)) { 
                    this.message = `Cannot upgrade to duplicate (${tempSimulatedCard.rankStr} of ${tempSimulatedCard.suit}). Choose another card.`; 
                    this.updateUI(); 
                    return; 
                }

                cardToModify.rank = newRank;
                cardToModify.rankStr = cardToModify.getRankStr();
                this.message = "Card Upgraded! Choose cards to HOLD.";
                
            } else if (this.activeEffect === "flush_fever") {
                const suitCounts = hand.reduce((counts, card) => {
                    counts.set(card.suit, (counts.get(card.suit) || 0) + 1);
                    return counts;
                }, new Map());
                
                let mostCommonSuit = null;
                let maxCount = 0;
                for (const [suit, count] of suitCounts.entries()) {
                    if (count > maxCount) { mostCommonSuit = count; mostCommonSuit = suit; }
                }
                
                if (mostCommonSuit && cardToModify.suit !== mostCommonSuit) {
                    const tempSimulatedCard = new Card(mostCommonSuit, cardToModify.rank);

                    if (cardExists(hand, tempSimulatedCard, clickedCardIndex)) {
                        this.message = `Cannot change to duplicate (${tempSimulatedCard.rankStr} of ${tempSimulatedCard.suit}). Choose another card.`; 
                        this.updateUI(); 
                        return;
                    }
                    cardToModify.suit = mostCommonSuit;
                    this.message = "Suit changed! Choose cards to HOLD.";
                } else {
                    this.message = "No suit change needed. Choose cards to HOLD.";
                }
            }
            
            this.endActionCardEffect();
        }

        endActionCardEffect() {
            if (this.selectedActionCard) {
                const originalCard = this.actionCardsInHand.find(ac => ac.name === this.selectedActionCard.name);
                if (originalCard) originalCard.isUsed = true;
            }
            this.selectedActionCard = null;
            this.activeEffect = null;
            this.gameState = "ACTION_PHASE";
            this.updateUI();
        }

        // --- UI Rendering Logic ---
        updateUI() {
            // Update Stats Bar
            document.getElementById('credits-stat').textContent = this.credits;
            document.getElementById('winnings-stat').textContent = this.lastWinnings;
            document.getElementById('bet-stat').textContent = this.bet + this.modCardCost;
            document.getElementById('message-area').textContent = this.message;

            // Update Control Buttons
            document.getElementById('deal-button').disabled = (this.gameState !== "DEAL" && this.gameState !== "END_ROUND");
            document.getElementById('draw-button').disabled = (this.gameState !== "ACTION_PHASE" || this.activeEffect);

            // Update Payout Table Highlights (RESET and APPLY)
            const payoutRows = document.querySelectorAll('#payout-table tbody tr');
            payoutRows.forEach(row => {
                row.classList.remove('highlight-win');
                if (this.gameState === "END_ROUND" && row.getAttribute('data-hand') === this.winningHandName) {
                    row.classList.add('highlight-win');
                }
            });


            // Update Cards and Hold Buttons
            const cardArea = document.getElementById('card-area');
            cardArea.innerHTML = '';

            this.playerHand.forEach((card, index) => {
                const slot = document.createElement('div');
                slot.className = 'card-slot';

                const cardDiv = document.createElement('div');
                cardDiv.className = 'card-image';
                
                // Set image as background
                const cardImagePath = `cards/${card.rankStr}_of_${card.suit}.png`;
                cardDiv.style.backgroundImage = `url('${cardImagePath}')`;
                cardDiv.style.backgroundSize = 'cover';

                // Image/Fallback visibility check
                if (cardDiv.style.backgroundImage && !cardDiv.style.backgroundImage.includes('url("")')) {
                    cardDiv.classList.add('has-image');
                } else {
                    cardDiv.classList.remove('has-image');
                }

                // Fallback (Text with Red/Black color) and Color Fix
                cardDiv.textContent = card.toString();
                if (card.suit === 'hearts' || card.suit === 'diamonds') {
                    cardDiv.classList.add('red-suit');
                } else {
                    cardDiv.classList.remove('red-suit');
                }
                
                // APPLY HOLD VISUALS (Border change is in CSS)
                if (this.heldCards[index]) cardDiv.classList.add('held');
                
                cardDiv.onclick = () => this.toggleHold(index);

                const holdButton = document.createElement('button');
                holdButton.className = 'hold-button';
                holdButton.textContent = this.heldCards[index] ? "HELD" : "HOLD";
                holdButton.disabled = (this.gameState !== "ACTION_PHASE" || this.activeEffect);
                holdButton.onclick = () => this.toggleHold(index);
                if (this.heldCards[index]) holdButton.classList.add('held');

                slot.appendChild(cardDiv);
                if (this.gameState === "ACTION_PHASE") {
                    slot.appendChild(holdButton);
                }
                cardArea.appendChild(slot);
            });
            
            // Update Joker Cards
            const actionContainer = document.getElementById('action-cards-container');
            actionContainer.innerHTML = '';
            
            const ACTION_CARD_IMAGE_PATH = 'Action_Cards/'; 
            
            this.actionCardsInHand.forEach(ac => {
                const slot = document.createElement('div');
                slot.className = 'action-card-slot';
                if (ac.isUsed) slot.classList.add('used');
                
                const button = document.createElement('button');
                button.className = 'action-card-button';
                
                // Set Action Card image as background
                button.style.backgroundImage = `url('${ACTION_CARD_IMAGE_PATH}${ac.filename}')`;
                button.style.backgroundSize = 'contain';
                
                button.textContent = ac.display; 
                
                if (this.selectedActionCard && this.selectedActionCard.name === ac.name) button.classList.add('selected');

                button.disabled = (ac.isUsed || this.actionCardUsedThisRound && !(this.selectedActionCard && this.selectedActionCard.name === ac.name));
                button.onclick = () => this.selectActionCard(ac.name);
                
                slot.appendChild(button);
                actionContainer.appendChild(slot);
            });
        }
    }

    // Initialize the game when the script loads
    const game = new PokerGame();
</script>

</body>
</html>